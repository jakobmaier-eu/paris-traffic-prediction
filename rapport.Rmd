---
title: "Rapport projet R"
author: "Jakob Maier, Guillaume Lambert"
date: "25/12/2021"
output:
  bookdown::html_document2: default
  bookdown::pdf_document2: default
bibliography: references.bib
link-citations: true
---

```{r librairies, include=FALSE, eval=TRUE}
library(XML)
library(RCurl)
library(magrittr)
library(mgcv)
library(tidyverse)
library(dplyr)
library(lubridate)
library(weathermetrics)
library(ranger)
```


# Le jeu de données

## Présentation des données

On présente maintenant les données que l'on a collectées et traitées afin de les utiliser dans la tâche de prédiction.

**Données de comptage routier**

Les données de comptage routier sont disponibles sur le site **Paris Data** [@parisData], regroupant les jeux de données de la Ville de Paris, disponibles sur le site [@donneesComptage]. Elles sont collectées grâce à des boucles électromagnétiques implantées dans la chaussée sur plus de 3000 tronçons de voies. L'historique des données s'étend de 2014 à ???? au pas horaire, selon la variable **t_1h**. Chaque boucle électromagnétique mesure le traffic sur un arc entre un noeud amont et un noeud aval. Deux données principales sont fournies : le **taux d'occupation**, **k**, qui correspond au temps de présence de véhicules sur la boucle en pourcentage d’une heure et le **débit**, **q** qui est  le nombre de véhicules ayant passé le point de comptage pendant une heure. Nous gardons également d'autres variables : l'identifiant de l'arc, **iu_ac**, le libellé de la voie correspondante, **libelle** et l'état de l'arc, **state**. Ce dernier vaut 0 si l'état est inconnu, 1 si l'arc est ouvert à la circulation, 2 l'arc est fermé à la circulation et 3 si l'arc est invalide. Il n'est malheureusement pas expliqué la différence entre arc fermé et arc invalide dans la documentation. 

Pour une année, il y a environ 29 millions observations réparties sur plus de 3000 points. On a donc procédé à une transformation des données afin de réduire leur nombre et les structurer. La première étape est l'agrégation des points d'observations selon les libellés **libelle** associés dans le jeu de données et à l'aide de leur identifiant **iu_ac**. Ensuite, on a déterminé les principaux axes de Paris en moyennant le nombre de voitures par heure des points d'observations partageant un même libellé puis en choisissant les 200 premières valeurs (hors périphérique). On obtient le graphique \@ref(fig:200mainstreets) et on en déduit le graphe simplifié \@ref(fig:graphe) de Paris composé de 69 arêtes, correspondant à 69 jeux de données.

```{r 200mainstreets, out.width='25%', fig.align='center', fig.show='hold', fig.cap="Représentation en rouge des points d'observation associés aux 200 libellés les plus fréquentés (hors périphérique)", echo = F}
knitr::include_graphics('figures/200mainstreets.png')
```

```{r graphe, out.width='25%', fig.align='center', fig.show='hold', fig.cap="Graphe simplifié de Paris", echo = F}
knitr::include_graphics('figures/graphe.png')
```

On obtient finalement 2 variables au pas horaire : **nbCar** (nom des variables) le nombre de voitures et **rateCar** le taux d'occupation. A partir de ces 2 variables, on en construit des autres en les retardant, d'une semaine (**nbCarLaggedWeek**, **rateCarLaggedWeek**), d'un jour (**nbCarLaggedDay**, **rateCarLaggedDay**) et d'une heure (**nbCarLaggedHour**, **rateCarLaggedHour**). En effet, il semble pertinent d'observer l'état du traffic routier à des temps antérieurs : historique à très court terme de l'eure précédente et historique au même instant du cycle journalier et hebdomadaire précédent. Cela est confirmé dans la partie ????.

Enfin, il est très important de noter que ces données sont incomplètes. Une étude approfondie de cette incomplétude et de la complétion est faite dans la partie ????.

**Variables temporelles**

Le traffic routier étant relié à l'activité humaine, nous avons ajouté de nombreuses variables temporelles (notamment grâce à la librairie *lubridate*).

- **year**, **month**, **day**, **hour** en décomposant la variable **t_1h**
- **time** le numéro de l'observation
- **toy** de 0 à 1 selon la position de l'observation dans l'année en cours
- **weekdays** le jour de la semaine et **weekendsIndicator** l'indicatrice si le jour est un jour du weekend
- **winterHolidaysIndicator** et **summerHolidaysIndicator** les indicatrices des vacances d'hiver et d'été définies à partir de [@calendrierScolaire]
- **bankHolidaysIndicator** l'indicatrice des jours fériés défini à partir de [@joursFeries]

**Index de la situation sanitaire en rapport avec le Covid-19**

Nous avons également ajouté, **covidIndex**, un index allant de 0 à 100 représentant les restrictions du gouvernement sur la situation sanitaire en rapport avec le Covid-19. Il est calculé à partir de nombreux indicateurs et est fourni par l'université d'Oxford [@covidIndex].

**Météo**

A partir de données de l'Organisation Météorologique Mondiale [@meteoData], nous avons extrait 2 variables météorologiques : **temperature** la température en Kelvin et **precipitation** les précipitations dans les 3 dernières heures en mm. Ces données ont été mesurées à Athis-Mons en Essonne. 

On dispose d'un relevé tous les 3 heures environ donc on procède à une interpolation pour compléter les données. Etant donné que les mesures sont uniformément réparties, on utilise une interpolation linéaire basique à l'aide de la fonction *na.approx* de la librairie *zoo*.

## Complétion du jeux de données du comptage routier

Malgré l'agrégation de plusieurs capteurs de mesure pour chaque arête, le jeu de données agrégé du comptage routier est incomplet et une partie importante du travail a été de le compléter. On représente dans la figure \@ref(fig:histograms) les histogrammes des pourcentages de valeurs manquantes. Les observations brutes du jeu de données sont de 2 types : mesure du taux d'occupation seul et mesure du taux d'occupation et du nombre de voiture (selon le type de capteur implanté dans la chaussée). Ainsi, il y a moins de mesures du nombre de voitures, comme on peut le voir sur les histogrammes des données agrégées. 

```{r histograms, echo=FALSE, fig.cap="Histogrammes", eval=TRUE}
edges = readRDS("Data/data_agg69_plain/edges_dfs_allyrs.rds")

perctNbCar = c()
perctRateCar = c()
nbInd = nrow(edges[[1]])

for(l in 1:69){
  perctNbCar = c(perctNbCar, sum(is.na(edges[[l]]$q))/nbInd)
  perctRateCar = c(perctRateCar, sum(is.na(edges[[l]]$k))/nbInd)
}

par(mfrow=c(1,2)) 
hist(perctNbCar, breaks=seq(0,1,0.01), main = "Nombre de voitures", xlab = "% de valeurs manquantes", ylab = "Effectif")
hist(perctRateCar, breaks=seq(0,1,0.01), main = "Taux d'occupation", xlab = "% de valeurs manquantes", ylab = "Effectif")
```







